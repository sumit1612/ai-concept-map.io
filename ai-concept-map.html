<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>AI / LLM / Agentic AI — Concept Map</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap');

  :root {
    --bg: #0a0c10; --bg2: #0e1018;
    --surface: #14171f; --surface2: #1c2030; --surface3: #242938;
    --border: #2a2f42; --border2: #363c54;
    --text: #eaedf6; --text2: #c8cdd8; --muted: #7c82a0;
    --accent: #6c8cff; --accent2: #a78bfa; --accent3: #818cf8;
    --know: #34d399; --fuzzy: #fbbf24; --unknown: #f87171;
    --pink: #f472b6; --green: #34d399; --gold: #fbbf24;
    --radius: 8px; --radius-lg: 12px;
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  body {
    font-family: 'Inter', system-ui, -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    height: 100vh;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }

  /* ── Topbar ── */
  #topbar {
    display: flex; align-items: center; gap: 8px;
    padding: 10px 20px;
    background: linear-gradient(180deg, var(--surface) 0%, var(--bg) 100%);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0; flex-wrap: wrap;
  }
  #topbar h1 {
    font-size: 15px; font-weight: 700; white-space: nowrap;
    background: linear-gradient(135deg, #6c8cff, #a78bfa, #f472b6);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
    background-clip: text;
  }
  .sep { width: 1px; height: 22px; background: var(--border); margin: 0 4px; }

  .btn-group { display: flex; gap: 1px; background: var(--border); border-radius: var(--radius); overflow: hidden; }
  .btn-group .gbtn {
    background: var(--surface2); border: none; color: var(--muted);
    padding: 5px 12px; cursor: pointer; font-size: 11px; font-weight: 500;
    font-family: inherit; transition: all .15s;
  }
  .btn-group .gbtn:hover { background: var(--surface3); color: var(--text2); }
  .btn-group .gbtn.active { background: var(--accent); color: #fff; }
  .btn-group .gbtn.active-purple { background: var(--accent2); color: #fff; }
  .btn-group .gbtn.active-pink { background: var(--pink); color: #fff; }

  .spacer { flex: 1; }
  .hint { font-size: 10px; color: var(--muted); opacity: .6; letter-spacing: .2px; }

  .legend { display: flex; gap: 12px; font-size: 11px; color: var(--muted); align-items: center; }
  .legend span { display: flex; align-items: center; gap: 5px; font-weight: 500; }
  .legend .dot { width: 8px; height: 8px; border-radius: 50%; }

  /* ── Main ── */
  #main { display: flex; flex: 1; overflow: hidden; }

  /* ── Sidebar ── */
  #sidebar {
    width: 340px; min-width: 280px;
    background: var(--surface);
    border-right: 1px solid var(--border);
    display: flex; flex-direction: column;
    overflow: hidden; flex-shrink: 0;
  }
  .sidebar-section { border-bottom: 1px solid var(--border); }
  .sidebar-section h2 {
    font-size: 10px; text-transform: uppercase; letter-spacing: 1.2px;
    color: var(--muted); padding: 12px 16px 6px; font-weight: 600;
  }

  #search-wrap { padding: 10px 16px; }
  #search {
    width: 100%;
    background: var(--surface2); border: 1px solid var(--border);
    color: var(--text); padding: 8px 12px;
    border-radius: var(--radius); font-size: 13px;
    font-family: inherit; outline: none; transition: .2s;
  }
  #search:focus { border-color: var(--accent); box-shadow: 0 0 0 3px rgba(108,140,255,.15); }
  #search::placeholder { color: var(--muted); }

  .actions-row { display: flex; gap: 6px; padding: 8px 16px; flex-wrap: wrap; }
  .action-btn {
    font-size: 11px; padding: 5px 12px;
    border-radius: var(--radius); border: 1px solid var(--border);
    background: var(--surface2); color: var(--text2);
    cursor: pointer; font-family: inherit; font-weight: 500; transition: .15s;
  }
  .action-btn:hover { border-color: var(--accent); color: var(--accent); background: rgba(108,140,255,.08); }

  /* ── Node list ── */
  #node-list { flex: 1; overflow-y: auto; padding: 2px 0; }
  .layer-group + .layer-group { border-top: 1px solid var(--border); }
  .layer-group-header {
    display: flex; align-items: center; gap: 8px;
    padding: 10px 16px; cursor: pointer; user-select: none;
    transition: .15s;
  }
  .layer-group-header:hover { background: var(--surface2); }
  .layer-group-header .arrow {
    font-size: 9px; color: var(--muted);
    transition: transform .2s; width: 14px; text-align: center;
  }
  .layer-group-header .arrow.collapsed { transform: rotate(-90deg); }
  .layer-group-header .layer-name { font-size: 12px; font-weight: 600; flex: 1; }
  .layer-group-header .layer-badge {
    font-size: 10px; color: var(--muted); font-weight: 600;
    background: var(--surface2); padding: 2px 8px; border-radius: 10px;
  }
  .layer-group-body { overflow: hidden; transition: max-height .3s ease; }
  .layer-group-body.collapsed { max-height: 0 !important; }

  .node-item {
    display: flex; align-items: center; gap: 8px;
    padding: 6px 16px 6px 32px;
    cursor: pointer; font-size: 12px; transition: .1s;
  }
  .node-item:hover { background: var(--surface2); }
  .node-item.selected { background: rgba(108,140,255,.1); border-left: 2px solid var(--accent); padding-left: 30px; }
  .node-item.dimmed { opacity: .3; }
  .node-item .node-label { flex: 1; font-weight: 500; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; color: var(--text2); }
  .node-item:hover .node-label { color: var(--text); }

  .pill {
    display: inline-flex; align-items: center; gap: 4px;
    padding: 3px 10px; border-radius: 12px;
    cursor: pointer; font-size: 10px; font-weight: 600;
    letter-spacing: .3px; flex-shrink: 0;
    border: 1px solid transparent; transition: all .15s;
    user-select: none; text-transform: uppercase;
    font-family: inherit;
  }
  .pill:hover { transform: scale(1.06); filter: brightness(1.2); }
  .pill .pill-dot { width: 6px; height: 6px; border-radius: 50%; }
  .pill.know { background: rgba(52,211,153,.12); color: #34d399; border-color: rgba(52,211,153,.25); }
  .pill.know .pill-dot { background: #34d399; }
  .pill.fuzzy { background: rgba(251,191,36,.12); color: #fbbf24; border-color: rgba(251,191,36,.25); }
  .pill.fuzzy .pill-dot { background: #fbbf24; }
  .pill.unknown { background: rgba(248,113,113,.12); color: #f87171; border-color: rgba(248,113,113,.25); }
  .pill.unknown .pill-dot { background: #f87171; }

  /* ── Canvas ── */
  #canvas-wrap { flex: 1; position: relative; overflow: hidden; background: var(--bg2); }
  canvas#canvas { display: block; width: 100%; height: 100%; }

  #tooltip {
    position: absolute; pointer-events: none;
    background: var(--surface); border: 1px solid var(--border2);
    border-radius: var(--radius-lg); padding: 14px 18px;
    font-size: 13px; max-width: 320px; z-index: 10; display: none;
    box-shadow: 0 8px 32px rgba(0,0,0,.5), 0 0 0 1px rgba(255,255,255,.03);
    backdrop-filter: blur(8px);
  }
  #tooltip .tt-title { font-weight: 700; margin-bottom: 6px; font-size: 14px; }
  #tooltip .tt-desc { color: var(--muted); line-height: 1.6; font-size: 12px; }
  #tooltip .tt-layer { font-size: 10px; margin-top: 8px; font-weight: 600; letter-spacing: .5px; text-transform: uppercase; }
  #tooltip .tt-conn { font-size: 11px; color: var(--muted); margin-top: 6px; font-style: italic; }

  #focus-banner {
    display: none; position: absolute; top: 14px; left: 50%; transform: translateX(-50%);
    background: var(--surface); border: 1px solid var(--accent);
    border-radius: var(--radius-lg); padding: 8px 20px;
    font-size: 12px; font-weight: 600; z-index: 5;
    color: var(--accent); cursor: pointer;
    box-shadow: 0 4px 20px rgba(108,140,255,.15);
    transition: .15s;
  }
  #focus-banner:hover { background: var(--accent); color: #fff; }

  #minimap {
    position: absolute; bottom: 14px; right: 14px;
    width: 190px; height: 140px;
    background: var(--surface); border: 1px solid var(--border);
    border-radius: var(--radius-lg); z-index: 5; overflow: hidden;
    cursor: pointer; box-shadow: 0 4px 16px rgba(0,0,0,.3);
  }
  #minimap canvas { width: 100%; height: 100%; display: block; }

  /* ── Prompt ── */
  #prompt-panel {
    background: linear-gradient(0deg, var(--surface) 0%, var(--bg) 100%);
    border-top: 1px solid var(--border);
    padding: 12px 20px; display: flex; gap: 14px;
    align-items: flex-start; flex-shrink: 0; max-height: 160px;
  }
  #prompt-text {
    flex: 1; font-family: 'SF Mono', 'Fira Code', Menlo, Consolas, monospace;
    font-size: 11px; line-height: 1.6; color: var(--muted);
    overflow-y: auto; max-height: 136px; white-space: pre-wrap;
  }
  #copy-btn {
    background: linear-gradient(135deg, var(--accent), var(--accent2));
    color: #fff; border: none; padding: 8px 20px;
    border-radius: var(--radius); cursor: pointer;
    font-size: 12px; font-weight: 600; font-family: inherit;
    white-space: nowrap; flex-shrink: 0; transition: .15s;
    box-shadow: 0 2px 8px rgba(108,140,255,.25);
  }
  #copy-btn:hover { filter: brightness(1.15); transform: translateY(-1px); }

  /* ── Scrollbar ── */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--border2); }
</style>
</head>
<body>

<div id="topbar">
  <h1>AI / LLM / Agentic AI</h1>
  <div class="sep"></div>

  <div class="btn-group" id="preset-group">
    <button class="gbtn active" data-preset="all">All</button>
    <button class="gbtn" data-preset="foundations">Foundations</button>
    <button class="gbtn" data-preset="core-tech">Core Tech</button>
    <button class="gbtn" data-preset="implementation">Implement</button>
    <button class="gbtn" data-preset="scaling">Scale</button>
    <button class="gbtn" data-preset="agentic">Agentic</button>
  </div>

  <div class="sep"></div>

  <div class="btn-group" id="layout-group">
    <button class="gbtn active-purple" data-layout="horizontal">Horizontal</button>
    <button class="gbtn" data-layout="radial">Radial</button>
  </div>

  <div class="sep"></div>

  <div class="btn-group" id="size-group">
    <button class="gbtn" data-size="S">S</button>
    <button class="gbtn active-pink" data-size="M">M</button>
    <button class="gbtn" data-size="L">L</button>
  </div>
  <span class="hint">Text Size</span>

  <div class="spacer"></div>
  <span class="hint">Click = focus &nbsp; Dbl-click = knowledge &nbsp; Scroll = zoom</span>
  <div class="sep"></div>
  <div class="legend">
    <span><span class="dot" style="background:var(--know)"></span>Know</span>
    <span><span class="dot" style="background:var(--fuzzy)"></span>Fuzzy</span>
    <span><span class="dot" style="background:var(--unknown)"></span>Unknown</span>
  </div>
</div>

<div id="main">
  <div id="sidebar">
    <div class="sidebar-section">
      <div id="search-wrap"><input id="search" placeholder="Search concepts..." oninput="filterNodes()"></div>
    </div>
    <div class="sidebar-section">
      <h2>Actions</h2>
      <div class="actions-row">
        <button class="action-btn" onclick="runAutoLayout()">Auto-Layout</button>
        <button class="action-btn" onclick="resetKnowledge()">Reset</button>
        <button class="action-btn" onclick="markAllKnow()">All Know</button>
        <button class="action-btn" onclick="centerView()">Fit View</button>
        <button class="action-btn" onclick="clearFocus()">Unfocus</button>
      </div>
    </div>
    <div id="node-list"></div>
  </div>

  <div id="canvas-wrap">
    <canvas id="canvas"></canvas>
    <div id="tooltip">
      <div class="tt-title"></div>
      <div class="tt-desc"></div>
      <div class="tt-layer"></div>
      <div class="tt-conn"></div>
    </div>
    <div id="focus-banner" onclick="clearFocus()">Focused: <span id="focus-label"></span> — click to clear</div>
    <div id="minimap"><canvas id="minimap-canvas"></canvas></div>
  </div>
</div>

<div id="prompt-panel">
  <div id="prompt-text">Adjust knowledge levels to generate a learning prompt.</div>
  <button id="copy-btn" onclick="copyPrompt()">Copy Prompt</button>
</div>

<script>
// ══════════════════════════════════════════════════════════════════════
// DATA
// ══════════════════════════════════════════════════════════════════════
const LAYERS = [
  { id:'L1', label:'Foundational Principles', short:'Found.', color:'#6c8cff' },
  { id:'L2', label:'Core Technologies', short:'Core', color:'#a78bfa' },
  { id:'L3', label:'Implementation', short:'Impl.', color:'#f472b6' },
  { id:'L4', label:'Scaling & Production', short:'Scale', color:'#34d399' },
  { id:'L5', label:'Agentic AI', short:'Agent', color:'#fbbf24' },
];
const LM = {}; LAYERS.forEach(l => LM[l.id] = l);

const ND = [
  { id:'linear_algebra', label:'Linear Algebra', layer:'L1', desc:'Vectors, matrices, tensor operations — the mathematical language of neural networks. Dot products drive attention; eigendecomposition underlies PCA and spectral methods.' },
  { id:'probability', label:'Probability &\nStatistics', layer:'L1', desc:'Bayesian inference, distributions, maximum likelihood estimation. Models learn by maximizing log-likelihood of training data.' },
  { id:'information_theory', label:'Information\nTheory', layer:'L1', desc:'Entropy, cross-entropy loss, KL divergence, mutual information. Cross-entropy is the standard LLM training objective.' },
  { id:'calculus_optim', label:'Calculus &\nOptimization', layer:'L1', desc:'Gradient descent, backpropagation, loss landscapes, saddle points. Adam optimizer combines momentum with adaptive learning rates.' },
  { id:'computational_complexity', label:'Computational\nComplexity', layer:'L1', desc:'Time/space complexity of attention (O(n²)), approximation algorithms, NP-hardness of combinatorial search in planning.' },
  { id:'learning_theory', label:'Statistical\nLearning Theory', layer:'L1', desc:'Bias-variance tradeoff, PAC learning, generalization bounds, VC dimension. Scaling laws relate model size, data, and compute to loss.' },
  { id:'neural_computation', label:'Neural\nComputation', layer:'L1', desc:'Perceptrons → MLPs → universal approximation theorem. How composing simple nonlinear units enables representation of complex functions.' },
  { id:'representation_learning', label:'Representation\nLearning', layer:'L1', desc:'Learning useful features from raw data. Embeddings map discrete tokens to continuous vector spaces; autoencoders learn compressed representations.' },

  { id:'transformer', label:'Transformer', layer:'L2', desc:'Self-attention + feed-forward layers. Enables parallel training over sequences. Foundation of GPT, BERT, T5, and all modern LLMs.' },
  { id:'attention', label:'Attention\nMechanisms', layer:'L2', desc:'Scaled dot-product attention: Q·K^T/√d → softmax → V. Multi-head attention captures different relationship types in parallel.' },
  { id:'tokenization', label:'Tokenization\n(BPE)', layer:'L2', desc:'Byte-pair encoding, WordPiece, SentencePiece break text into subword tokens. Vocabulary size (32K–200K) affects efficiency.' },
  { id:'positional_encoding', label:'Positional\nEncoding', layer:'L2', desc:'Sinusoidal, learned, RoPE, or ALiBi position signals. Enable sequence order understanding since attention is permutation-invariant.' },
  { id:'pretraining', label:'Pre-training', layer:'L2', desc:'Causal language modeling: predict next token given context. Trained on trillions of tokens. Captures syntax, semantics, factual knowledge.' },
  { id:'finetuning', label:'Fine-tuning\n& SFT', layer:'L2', desc:'Supervised fine-tuning on curated instruction-response pairs. Adapts pre-trained models to follow instructions and specific domains.' },
  { id:'rlhf', label:'RLHF / RLAIF', layer:'L2', desc:'Reinforcement Learning from Human/AI Feedback. Train a reward model, then optimize via PPO or DPO. Aligns outputs with preferences.' },
  { id:'context_window', label:'Long Context', layer:'L2', desc:'From 2K → 128K → 1M+ tokens. Techniques: RoPE scaling, ring attention, sparse attention. Enables processing entire codebases.' },
  { id:'moe', label:'Mixture of\nExperts', layer:'L2', desc:'Route each token to a subset of expert FFN sub-networks. Scales capacity without proportional compute (Mixtral, GPT-4).' },
  { id:'multimodal', label:'Multimodal\nModels', layer:'L2', desc:'Vision-language models (GPT-4V, Gemini), audio (Whisper), code. Encode different modalities into a shared embedding space.' },
  { id:'embedding_models', label:'Embedding\nModels', layer:'L2', desc:'Contrastive training for dense vector representations. Used for semantic search, retrieval, and clustering in RAG pipelines.' },
  { id:'reasoning', label:'Chain-of-\nThought', layer:'L2', desc:'Step-by-step reasoning via prompting or training. CoT prompting, scratchpads, reasoning tokens, verification chains.' },

  { id:'prompt_engineering', label:'Prompt\nEngineering', layer:'L3', desc:'System prompts, few-shot examples, chain-of-thought, structured outputs. The art of communicating intent clearly to LLMs.' },
  { id:'rag', label:'RAG', layer:'L3', desc:'Retrieve relevant documents from a vector DB, inject into context, then generate. Grounds responses in factual, up-to-date knowledge.' },
  { id:'vector_db', label:'Vector\nDatabases', layer:'L3', desc:'Pinecone, Weaviate, Qdrant, pgvector. Store and query high-dimensional embeddings with ANN algorithms (HNSW, IVF).' },
  { id:'function_calling', label:'Function\nCalling', layer:'L3', desc:'Models output structured JSON to invoke external APIs, databases, or code interpreters. Foundation for agentic behavior.' },
  { id:'eval_benchmarks', label:'Evaluation &\nBenchmarks', layer:'L3', desc:'MMLU, HumanEval, MATH, SWE-bench, Arena ELO. Measure reasoning, coding, factuality. LLM-as-judge for subjective tasks.' },
  { id:'lora', label:'LoRA / QLoRA', layer:'L3', desc:'Parameter-efficient fine-tuning: train low-rank adapters (<1% params) instead of the full model. Task-specific customization at low cost.' },
  { id:'guardrails', label:'Guardrails &\nSafety', layer:'L3', desc:'Constitutional AI, red-teaming, content filters, output validators. Prevent harmful, biased, or hallucinated outputs.' },
  { id:'structured_output', label:'Structured\nOutput', layer:'L3', desc:'Constrained decoding, grammar-guided generation, Pydantic schemas. Ensure model outputs conform to expected data structures.' },
  { id:'frameworks', label:'LangChain /\nLlamaIndex', layer:'L3', desc:'Orchestration libraries for chains, agents, RAG pipelines. Provide abstractions for common LLM application patterns.' },
  { id:'model_serving', label:'Model Serving\n(vLLM)', layer:'L3', desc:'High-throughput inference servers. Continuous batching, PagedAttention, speculative decoding, KV-cache optimization.' },

  { id:'scaling_laws', label:'Scaling Laws', layer:'L4', desc:'Loss scales as power law of compute, data, and parameters. Chinchilla: ~20 tokens per parameter. Guides training budgets.' },
  { id:'distributed_training', label:'Distributed\nTraining', layer:'L4', desc:'Data parallel, tensor parallel, pipeline parallel, FSDP, DeepSpeed ZeRO. Train 100B+ models across thousands of GPUs.' },
  { id:'quantization', label:'Quantization', layer:'L4', desc:'Reduce weight precision from FP16 to INT4/INT8. GPTQ, AWQ, GGUF. 2–4x memory reduction with minimal quality loss.' },
  { id:'distillation', label:'Knowledge\nDistillation', layer:'L4', desc:'Train a smaller student model to mimic a larger teacher. Transfers capabilities while dramatically reducing inference cost.' },
  { id:'inference_optim', label:'Inference\nOptimization', layer:'L4', desc:'KV-cache, flash attention, speculative decoding, continuous batching, prefix caching. Reduce latency and cost per token.' },
  { id:'gpu_infra', label:'GPU\nInfrastructure', layer:'L4', desc:'NVIDIA H100/B200, AMD MI300X, TPUs. NVLink, InfiniBand. Cloud (AWS, GCP, Azure) vs on-prem clusters.' },
  { id:'cost_optimization', label:'Cost\nOptimization', layer:'L4', desc:'Prompt caching, model routing, batch APIs, spot instances, output token budgeting. Minimize cost per request.' },
  { id:'observability', label:'Observability', layer:'L4', desc:'Token usage, latency P50/P99, error rates, hallucination detection, drift monitoring. LangSmith, Helicone, W&B.' },
  { id:'ci_cd_llm', label:'CI/CD for\nLLM Apps', layer:'L4', desc:'Prompt versioning, regression test suites, A/B testing, canary deployments, automated eval pipelines. Treat prompts as code.' },
  { id:'data_pipeline', label:'Data Pipelines', layer:'L4', desc:'Web crawling, deduplication, quality filtering, PII removal, synthetic data generation. Data quality drives model quality.' },

  { id:'agent_architecture', label:'Agent\nArchitecture', layer:'L5', desc:'Perceive → Think → Act → Observe loop. Combines LLM reasoning with tool use, memory, and planning for autonomous tasks.' },
  { id:'tool_use', label:'Tool Use\n& MCP', layer:'L5', desc:'Model Context Protocol standardizes tool integration. Agents use calculators, APIs, code execution, web browsing, file systems.' },
  { id:'planning', label:'Planning &\nDecomposition', layer:'L5', desc:'Break complex goals into sub-tasks. ReAct, tree-of-thought, hierarchical planning, backtracking on failure.' },
  { id:'memory_systems', label:'Memory\nSystems', layer:'L5', desc:'Short-term (context window), working (scratchpad), long-term (vector store). Episodic memory stores past interactions.' },
  { id:'multi_agent', label:'Multi-Agent\nSystems', layer:'L5', desc:'Multiple specialized agents collaborate: debate, delegate, review. Patterns: supervisor, swarm, pipeline, democratic voting.' },
  { id:'code_agents', label:'Code Agents', layer:'L5', desc:'Agents that read, write, test, and debug code autonomously. Claude Code, Devin, SWE-Agent. Navigate repos, run tests, submit PRs.' },
  { id:'agent_frameworks', label:'Agent\nFrameworks', layer:'L5', desc:'Claude Agent SDK, CrewAI, AutoGen, LangGraph. Orchestration for agent loops, tool management, state machines.' },
  { id:'human_in_loop', label:'Human-in-\nthe-Loop', layer:'L5', desc:'Approval gates, escalation policies, confidence thresholds. Critical for high-stakes actions: deployments, transactions, emails.' },
  { id:'agent_eval', label:'Agent\nEvaluation', layer:'L5', desc:'Task completion rate, tool call efficiency, cost per task, safety violations. SWE-bench, WebArena, GAIA benchmarks.' },
  { id:'autonomous_ops', label:'Autonomous\nOps', layer:'L5', desc:'Self-healing infrastructure, automated incident response, continuous deployment agents. Agents with minimal human supervision.' },
];

const ED = [
  { from:'linear_algebra', to:'probability', label:'Covariance, distributions' },
  { from:'probability', to:'information_theory', label:'Entropy from distributions' },
  { from:'calculus_optim', to:'learning_theory', label:'Convergence analysis' },
  { from:'linear_algebra', to:'neural_computation', label:'Matrix multiplications' },
  { from:'probability', to:'learning_theory', label:'Generalization bounds' },
  { from:'neural_computation', to:'representation_learning', label:'Learned features' },
  { from:'linear_algebra', to:'attention', label:'Q·K^T dot products' },
  { from:'information_theory', to:'pretraining', label:'Cross-entropy loss' },
  { from:'calculus_optim', to:'pretraining', label:'Backprop & Adam' },
  { from:'neural_computation', to:'transformer', label:'Layered composition' },
  { from:'representation_learning', to:'embedding_models', label:'Dense vector spaces' },
  { from:'learning_theory', to:'scaling_laws', label:'Power-law predictions' },
  { from:'computational_complexity', to:'context_window', label:'O(n²) attention cost' },
  { from:'representation_learning', to:'tokenization', label:'Subword embeddings' },
  { from:'attention', to:'transformer', label:'Core mechanism' },
  { from:'tokenization', to:'transformer', label:'Input tokens' },
  { from:'positional_encoding', to:'transformer', label:'Position signals' },
  { from:'transformer', to:'pretraining', label:'Architecture for training' },
  { from:'pretraining', to:'finetuning', label:'Base → instruction model' },
  { from:'finetuning', to:'rlhf', label:'SFT → alignment' },
  { from:'transformer', to:'moe', label:'Expert routing layers' },
  { from:'transformer', to:'multimodal', label:'Multi-modal encoders' },
  { from:'transformer', to:'context_window', label:'Memory scales with length' },
  { from:'pretraining', to:'reasoning', label:'Emergent capabilities' },
  { from:'rlhf', to:'reasoning', label:'Preference for correct steps' },
  { from:'transformer', to:'embedding_models', label:'Encoder architectures' },
  { from:'pretraining', to:'prompt_engineering', label:'In-context learning' },
  { from:'embedding_models', to:'rag', label:'Semantic retrieval' },
  { from:'embedding_models', to:'vector_db', label:'Vectors to index' },
  { from:'finetuning', to:'lora', label:'Efficient adaptation' },
  { from:'rlhf', to:'guardrails', label:'Alignment training' },
  { from:'reasoning', to:'function_calling', label:'When to call tools' },
  { from:'context_window', to:'rag', label:'Retrieved doc budget' },
  { from:'multimodal', to:'eval_benchmarks', label:'Multi-modal evals' },
  { from:'transformer', to:'model_serving', label:'Architecture to serve' },
  { from:'reasoning', to:'structured_output', label:'Format following' },
  { from:'rag', to:'vector_db', label:'Retrieval backend' },
  { from:'prompt_engineering', to:'structured_output', label:'Output formatting' },
  { from:'function_calling', to:'frameworks', label:'Tool orchestration' },
  { from:'guardrails', to:'eval_benchmarks', label:'Safety metrics' },
  { from:'lora', to:'model_serving', label:'Adapted weights' },
  { from:'frameworks', to:'rag', label:'RAG pipelines' },
  { from:'model_serving', to:'inference_optim', label:'Serving optimizations' },
  { from:'eval_benchmarks', to:'ci_cd_llm', label:'Regression testing' },
  { from:'model_serving', to:'gpu_infra', label:'GPU compute' },
  { from:'lora', to:'cost_optimization', label:'Cheaper fine-tuning' },
  { from:'guardrails', to:'observability', label:'Safety monitoring' },
  { from:'prompt_engineering', to:'ci_cd_llm', label:'Prompt versioning' },
  { from:'scaling_laws', to:'distributed_training', label:'Compute allocation' },
  { from:'distributed_training', to:'gpu_infra', label:'Multi-GPU clusters' },
  { from:'quantization', to:'inference_optim', label:'Reduced precision' },
  { from:'distillation', to:'cost_optimization', label:'Smaller models' },
  { from:'inference_optim', to:'cost_optimization', label:'Lower cost/token' },
  { from:'observability', to:'ci_cd_llm', label:'Deployment confidence' },
  { from:'data_pipeline', to:'distributed_training', label:'Training data' },
  { from:'data_pipeline', to:'scaling_laws', label:'Data availability' },
  { from:'function_calling', to:'tool_use', label:'API invocation' },
  { from:'rag', to:'memory_systems', label:'Long-term retrieval' },
  { from:'frameworks', to:'agent_frameworks', label:'Chains → agents' },
  { from:'structured_output', to:'agent_architecture', label:'Structured actions' },
  { from:'eval_benchmarks', to:'agent_eval', label:'Task-level evals' },
  { from:'guardrails', to:'human_in_loop', label:'Safety gates' },
  { from:'cost_optimization', to:'multi_agent', label:'Budget per agent' },
  { from:'inference_optim', to:'agent_architecture', label:'Fast agent loops' },
  { from:'observability', to:'agent_eval', label:'Agent monitoring' },
  { from:'ci_cd_llm', to:'autonomous_ops', label:'Automated deployment' },
  { from:'agent_architecture', to:'planning', label:'Think step' },
  { from:'agent_architecture', to:'tool_use', label:'Act step' },
  { from:'agent_architecture', to:'memory_systems', label:'Remember step' },
  { from:'planning', to:'multi_agent', label:'Task delegation' },
  { from:'tool_use', to:'code_agents', label:'Code execution' },
  { from:'agent_frameworks', to:'multi_agent', label:'Agent coordination' },
  { from:'agent_frameworks', to:'code_agents', label:'SWE tooling' },
  { from:'human_in_loop', to:'autonomous_ops', label:'Approval → autonomy' },
  { from:'agent_eval', to:'autonomous_ops', label:'Trust threshold' },
  { from:'memory_systems', to:'multi_agent', label:'Shared context' },
  { from:'multi_agent', to:'autonomous_ops', label:'Complex workflows' },
];

// ══════════════════════════════════════════════════════════════════════
// SIZE PROFILES
// ══════════════════════════════════════════════════════════════════════
const SIZES = {
  S: { radius: 30, font: 10, fontBold: 11, labelWidth: 52, layerGap: 200, edgeLabel: 9 },
  M: { radius: 40, font: 12, fontBold: 13, labelWidth: 70, layerGap: 260, edgeLabel: 10 },
  L: { radius: 52, font: 14, fontBold: 15, labelWidth: 92, layerGap: 330, edgeLabel: 11 },
};
let SZ = SIZES.M;

// ══════════════════════════════════════════════════════════════════════
// STATE
// ══════════════════════════════════════════════════════════════════════
const NM = {};
const state = {
  nodes: ND.map(n => { const o = { ...n, x:0, y:0, knowledge:'fuzzy', visible:true }; NM[n.id]=o; return o; }),
  edges: ED.map(e => ({ ...e })),
  pan:{x:0,y:0}, zoom:1,
  dragging:null, dragOff:{x:0,y:0},
  hovered:null, selected:null, focusNode:null,
  searchQuery:'',
  layerFilters: new Set(LAYERS.map(l=>l.id)),
  collapsedLayers: new Set(),
  isPanning:false, panStart:{x:0,y:0},
  layoutMode:'horizontal', sizeMode:'M',
};

const adj = {};
state.nodes.forEach(n => adj[n.id] = new Set());
state.edges.forEach(e => { adj[e.from]?.add(e.to); adj[e.to]?.add(e.from); });
function neighbors(id) { return adj[id] || new Set(); }

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

// ══════════════════════════════════════════════════════════════════════
// LAYOUT
// ══════════════════════════════════════════════════════════════════════
function layerY(lid) { return 120 + LAYERS.findIndex(l=>l.id===lid) * SZ.layerGap; }

function horizontalLayout() {
  const g = {}; LAYERS.forEach(l => g[l.id]=[]);
  state.nodes.forEach(n => g[n.layer]?.push(n));
  LAYERS.forEach(l => {
    const ns = g[l.id];
    const sp = Math.max(SZ.radius*3.5, 1400/(ns.length+1));
    const sx = -(ns.length-1)*sp/2;
    ns.forEach((n,i) => { n.x = sx+i*sp; n.y = layerY(l.id); });
  });
}

function radialLayout() {
  const c = NM['transformer']; if(!c){horizontalLayout();return;}
  c.x=0; c.y=0;
  const place = (lid, radius, startA, spread, exclude) => {
    const ns = state.nodes.filter(n => n.layer===lid && (!exclude || !exclude.includes(n.id)));
    ns.forEach((n,i) => {
      const a = startA + (i/(ns.length-1||1))*spread;
      n.x = Math.cos(a)*radius; n.y = Math.sin(a)*radius;
    });
  };
  place('L2', 220, -Math.PI/2, Math.PI*2*(10/11), ['transformer']);
  place('L1', 460, Math.PI*0.65, Math.PI*0.8);
  place('L3', 500, -Math.PI*0.35, Math.PI*0.7);
  place('L4', 720, Math.PI*0.1, Math.PI*0.65);
  place('L5', 740, Math.PI*0.55, Math.PI*0.6);
}

function forceRelax() {
  const vis = state.nodes.filter(n=>n.visible);
  if(vis.length<2) return;
  const tY = {};
  if(state.layoutMode==='horizontal') vis.forEach(n => tY[n.id]=layerY(n.layer));
  const vx=new Map(), vy=new Map();
  vis.forEach(n=>{vx.set(n.id,0);vy.set(n.id,0);});
  for(let it=0;it<150;it++){
    for(let i=0;i<vis.length;i++) for(let j=i+1;j<vis.length;j++){
      const a=vis[i],b=vis[j];
      let dx=a.x-b.x, dy=a.y-b.y, d=Math.sqrt(dx*dx+dy*dy)||1;
      let f=14000/(d*d), fx=(dx/d)*f, fy=(dy/d)*f;
      if(state.layoutMode==='horizontal') fy*=0.15;
      vx.set(a.id,vx.get(a.id)+fx);vy.set(a.id,vy.get(a.id)+fy);
      vx.set(b.id,vx.get(b.id)-fx);vy.set(b.id,vy.get(b.id)-fy);
    }
    state.edges.forEach(e=>{
      const a=NM[e.from],b=NM[e.to];
      if(!a||!b||!a.visible||!b.visible)return;
      let dx=b.x-a.x,dy=b.y-a.y,d=Math.sqrt(dx*dx+dy*dy)||1;
      let f=0.004*d, fx=(dx/d)*f, fy=(dy/d)*f;
      vx.set(a.id,vx.get(a.id)+fx);vy.set(a.id,vy.get(a.id)+fy);
      vx.set(b.id,vx.get(b.id)-fx);vy.set(b.id,vy.get(b.id)-fy);
    });
    if(state.layoutMode==='horizontal') vis.forEach(n=>vy.set(n.id,vy.get(n.id)+(tY[n.id]-n.y)*0.1));
    vis.forEach(n=>{n.x+=vx.get(n.id);n.y+=vy.get(n.id);vx.set(n.id,vx.get(n.id)*0.88);vy.set(n.id,vy.get(n.id)*0.88);});
  }
}

function runAutoLayout(){
  state.layoutMode==='radial'?radialLayout():horizontalLayout();
  forceRelax(); centerView(); draw(); drawMinimap();
}

// ══════════════════════════════════════════════════════════════════════
// FOCUS
// ══════════════════════════════════════════════════════════════════════
function setFocus(n){state.focusNode=n;document.getElementById('focus-banner').style.display='block';document.getElementById('focus-label').textContent=n.label.replace(/\n/g,' ');draw();renderNodeList();drawMinimap();}
function clearFocus(){state.focusNode=null;state.selected=null;document.getElementById('focus-banner').style.display='none';draw();renderNodeList();drawMinimap();}
function inFocus(id){return !state.focusNode||id===state.focusNode.id||neighbors(state.focusNode.id).has(id);}
function edgeInFocus(e){return !state.focusNode||e.from===state.focusNode.id||e.to===state.focusNode.id;}

// ══════════════════════════════════════════════════════════════════════
// DRAWING
// ══════════════════════════════════════════════════════════════════════
function resize(){
  const w=document.getElementById('canvas-wrap');
  const dpr=devicePixelRatio||1;
  W=w.clientWidth;H=w.clientHeight;
  canvas.width=W*dpr;canvas.height=H*dpr;
  canvas.style.width=W+'px';canvas.style.height=H+'px';
  ctx.setTransform(dpr,0,0,dpr,0,0);
  draw();drawMinimap();
}
function toS(x,y){return{x:x*state.zoom+state.pan.x+W/2,y:y*state.zoom+state.pan.y+H/2};}
function toW(sx,sy){return{x:(sx-state.pan.x-W/2)/state.zoom,y:(sy-state.pan.y-H/2)/state.zoom};}

function hexToRgb(h){const r=parseInt(h.slice(1,3),16),g=parseInt(h.slice(3,5),16),b=parseInt(h.slice(5,7),16);return{r,g,b};}

function draw(){
  ctx.clearRect(0,0,W,H);
  ctx.save();
  ctx.translate(state.pan.x+W/2,state.pan.y+H/2);
  ctx.scale(state.zoom,state.zoom);

  const R = SZ.radius;
  const hasFocus = !!state.focusNode;

  // Layer bands
  if(state.layoutMode==='horizontal'){
    LAYERS.forEach(l=>{
      if(!state.layerFilters.has(l.id))return;
      const y=layerY(l.id);
      const {r,g,b}=hexToRgb(l.color);
      ctx.fillStyle=`rgba(${r},${g},${b},0.03)`;
      ctx.fillRect(-4000,y-SZ.layerGap/2,8000,SZ.layerGap);
      ctx.fillStyle=`rgba(${r},${g},${b},0.18)`;
      ctx.font=`600 13px Inter,system-ui`;
      ctx.textAlign='left';
      ctx.fillText(l.label,-3800,y-SZ.layerGap/2+18);
    });
  }

  // Edges
  state.edges.forEach(e=>{
    const f=NM[e.from],t=NM[e.to];
    if(!f||!t||!f.visible||!t.visible)return;
    const ef=edgeInFocus(e);
    const hl=state.hovered&&(state.hovered.id===f.id||state.hovered.id===t.id);
    const sl=state.selected&&(state.selected.id===f.id||state.selected.id===t.id);
    const hi=hl||sl;

    if(hasFocus&&!ef&&!hi){
      ctx.beginPath();ctx.moveTo(f.x,f.y);ctx.lineTo(t.x,t.y);
      ctx.strokeStyle='rgba(255,255,255,0.02)';ctx.lineWidth=0.5;ctx.stroke();
      return;
    }

    const mx=(f.x+t.x)/2,my=(f.y+t.y)/2;
    const dx=t.x-f.x,dy=t.y-f.y;
    const cx=mx+dy*0.08,cy=my-dx*0.08;
    ctx.beginPath();ctx.moveTo(f.x,f.y);ctx.quadraticCurveTo(cx,cy,t.x,t.y);

    const lc=LM[f.layer].color;
    if(hi||(hasFocus&&ef)){
      const {r,g,b}=hexToRgb(lc);
      ctx.strokeStyle=hi?`rgba(${r},${g},${b},0.8)`:`rgba(${r},${g},${b},0.5)`;
      ctx.lineWidth=hi?2.5:1.8;
    } else {
      ctx.strokeStyle='rgba(255,255,255,0.06)';ctx.lineWidth=1;
    }
    ctx.stroke();

    // Arrow
    if(hi||(hasFocus&&ef)){
      const tt=0.88;
      const ax=(1-tt)*(1-tt)*f.x+2*(1-tt)*tt*cx+tt*tt*t.x;
      const ay=(1-tt)*(1-tt)*f.y+2*(1-tt)*tt*cy+tt*tt*t.y;
      const ang=Math.atan2(t.y-ay,t.x-ax);
      const al=hi?12:9;
      ctx.beginPath();
      ctx.moveTo(t.x-Math.cos(ang-0.3)*(R+al),t.y-Math.sin(ang-0.3)*(R+al));
      ctx.lineTo(t.x-Math.cos(ang)*R,t.y-Math.sin(ang)*R);
      ctx.lineTo(t.x-Math.cos(ang+0.3)*(R+al),t.y-Math.sin(ang+0.3)*(R+al));
      ctx.fillStyle=ctx.strokeStyle;ctx.fill();
    }

    if(hi){
      ctx.font=`500 ${SZ.edgeLabel}px Inter,system-ui`;
      ctx.fillStyle='rgba(255,255,255,0.7)';ctx.textAlign='center';
      ctx.fillText(e.label,cx,cy-10);
    }
  });

  // Nodes
  state.nodes.forEach(n=>{
    if(!n.visible)return;
    const lc=LM[n.layer].color;
    const {r,g,b}=hexToRgb(lc);
    const hov=state.hovered?.id===n.id;
    const sel=state.selected?.id===n.id;
    const focused=inFocus(n.id);
    const dim=hasFocus&&!focused&&!hov;
    const kc=n.knowledge==='know'?'#34d399':n.knowledge==='fuzzy'?'#fbbf24':'#f87171';

    // Outer glow
    if((hov||sel)&&!dim){
      const grad=ctx.createRadialGradient(n.x,n.y,R,n.x,n.y,R+18);
      grad.addColorStop(0,`rgba(${r},${g},${b},0.2)`);
      grad.addColorStop(1,`rgba(${r},${g},${b},0)`);
      ctx.beginPath();ctx.arc(n.x,n.y,R+18,0,Math.PI*2);
      ctx.fillStyle=grad;ctx.fill();
    }

    // Node body with gradient
    ctx.beginPath();ctx.arc(n.x,n.y,R,0,Math.PI*2);
    if(dim){
      ctx.fillStyle='rgba(20,23,31,0.4)';ctx.fill();
      ctx.strokeStyle=`rgba(${r},${g},${b},0.08)`;ctx.lineWidth=1;
    } else {
      const grad=ctx.createRadialGradient(n.x-R*0.3,n.y-R*0.3,0,n.x,n.y,R);
      grad.addColorStop(0,`rgba(${r},${g},${b},${hov||sel?0.2:0.1})`);
      grad.addColorStop(1,`rgba(${r},${g},${b},${hov||sel?0.08:0.03})`);
      ctx.fillStyle=grad;ctx.fill();
      ctx.strokeStyle=`rgba(${r},${g},${b},${hov||sel?0.9:0.4})`;
      ctx.lineWidth=hov||sel?2.5:1.5;
    }
    ctx.stroke();

    // Knowledge badge
    if(!dim){
      const bx=n.x+R*0.62,by=n.y-R*0.62;
      ctx.beginPath();ctx.arc(bx,by,6,0,Math.PI*2);
      ctx.fillStyle=kc;ctx.fill();
      ctx.strokeStyle='rgba(10,12,16,0.6)';ctx.lineWidth=1.5;ctx.stroke();
    }

    // Label text
    const lines = n.label.split('\n');
    if(dim){
      ctx.font=`500 ${SZ.font-2}px Inter,system-ui`;
      ctx.fillStyle='rgba(255,255,255,0.1)';ctx.textAlign='center';
      ctx.fillText(lines.join(' '),n.x,n.y+4,R*2);
    } else {
      const fs = hov||sel ? SZ.fontBold : SZ.font;
      ctx.font=`${hov||sel?'700':'500'} ${fs}px Inter,system-ui`;
      ctx.fillStyle=hov||sel?'#fff':'rgba(234,237,246,0.9)';
      ctx.textAlign='center';

      if(lines.length===1){
        ctx.fillText(lines[0],n.x,n.y+fs/3,R*2-6);
      } else {
        const lh=fs+3;
        const startY=n.y-(lines.length-1)*lh/2+fs/3;
        lines.forEach((line,i)=>{
          ctx.fillText(line,n.x,startY+i*lh,R*2-6);
        });
      }
    }
  });

  ctx.restore();
}

// ══════════════════════════════════════════════════════════════════════
// MINIMAP
// ══════════════════════════════════════════════════════════════════════
function drawMinimap(){
  const mc=document.getElementById('minimap-canvas');
  const mw=190,mh=140,dpr=devicePixelRatio||1;
  mc.width=mw*dpr;mc.height=mh*dpr;
  const c=mc.getContext('2d');c.setTransform(dpr,0,0,dpr,0,0);
  c.clearRect(0,0,mw,mh);c.fillStyle='#0a0c10';c.fillRect(0,0,mw,mh);
  const vis=state.nodes.filter(n=>n.visible);if(!vis.length)return;
  let x1=Infinity,x2=-Infinity,y1=Infinity,y2=-Infinity;
  vis.forEach(n=>{x1=Math.min(x1,n.x);x2=Math.max(x2,n.x);y1=Math.min(y1,n.y);y2=Math.max(y2,n.y);});
  x1-=60;x2+=60;y1-=60;y2+=60;
  const rx=x2-x1||1,ry=y2-y1||1;
  const s=Math.min(mw/rx,mh/ry)*0.9;
  const ox=(mw-rx*s)/2,oy=(mh-ry*s)/2;
  const tx=x=>(x-x1)*s+ox,ty=y=>(y-y1)*s+oy;
  state.edges.forEach(e=>{const a=NM[e.from],b=NM[e.to];if(!a||!b||!a.visible||!b.visible)return;c.beginPath();c.moveTo(tx(a.x),ty(a.y));c.lineTo(tx(b.x),ty(b.y));c.strokeStyle='rgba(255,255,255,0.05)';c.lineWidth=0.5;c.stroke();});
  vis.forEach(n=>{c.beginPath();c.arc(tx(n.x),ty(n.y),3,0,Math.PI*2);c.fillStyle=LM[n.layer].color+'88';c.fill();});
  const tl=toW(0,0),br=toW(W,H);
  c.strokeStyle='rgba(255,255,255,0.25)';c.lineWidth=1;
  c.strokeRect(tx(tl.x),ty(tl.y),tx(br.x)-tx(tl.x),ty(br.y)-ty(tl.y));
  mc._mm={x1,y1,s,ox,oy};
}
document.getElementById('minimap').addEventListener('click',e=>{
  const mc=document.getElementById('minimap-canvas'),mm=mc._mm;if(!mm)return;
  const r=mc.getBoundingClientRect();
  const wx=(e.clientX-r.left-mm.ox)/mm.s+mm.x1;
  const wy=(e.clientY-r.top-mm.oy)/mm.s+mm.y1;
  state.pan.x=-wx*state.zoom;state.pan.y=-wy*state.zoom;
  draw();drawMinimap();
});

// ══════════════════════════════════════════════════════════════════════
// INTERACTION
// ══════════════════════════════════════════════════════════════════════
function hitTest(sx,sy){const{x,y}=toW(sx,sy);for(let i=state.nodes.length-1;i>=0;i--){const n=state.nodes[i];if(!n.visible)continue;const dx=n.x-x,dy=n.y-y;if(dx*dx+dy*dy<=SZ.radius*SZ.radius)return n;}return null;}

let ck=null,cn=null;

canvas.addEventListener('mousedown',e=>{
  const r=canvas.getBoundingClientRect(),sx=e.clientX-r.left,sy=e.clientY-r.top;
  const n=hitTest(sx,sy);ck={x:e.clientX,y:e.clientY,t:Date.now()};cn=n;
  if(n){state.dragging=n;const s=toS(n.x,n.y);state.dragOff={x:s.x-sx,y:s.y-sy};}
  else{state.isPanning=true;state.panStart={x:e.clientX-state.pan.x,y:e.clientY-state.pan.y};}
});

canvas.addEventListener('mousemove',e=>{
  const r=canvas.getBoundingClientRect(),sx=e.clientX-r.left,sy=e.clientY-r.top;
  if(state.dragging){const w=toW(sx+state.dragOff.x,sy+state.dragOff.y);state.dragging.x=w.x;state.dragging.y=w.y;draw();drawMinimap();return;}
  if(state.isPanning){state.pan.x=e.clientX-state.panStart.x;state.pan.y=e.clientY-state.panStart.y;draw();drawMinimap();return;}
  const n=hitTest(sx,sy);
  if(n!==state.hovered){
    state.hovered=n;draw();
    const tt=document.getElementById('tooltip');
    if(n){
      tt.style.display='block';
      tt.querySelector('.tt-title').textContent=n.label.replace(/\n/g,' ');
      tt.querySelector('.tt-desc').textContent=n.desc;
      tt.querySelector('.tt-layer').style.color=LM[n.layer].color;
      tt.querySelector('.tt-layer').textContent=LM[n.layer].label;
      tt.querySelector('.tt-conn').textContent=`${neighbors(n.id).size} connections — click to focus`;
      const ts=toS(n.x,n.y);
      let tx=ts.x+SZ.radius+14,ty=ts.y-30;
      if(tx+320>W)tx=ts.x-334;if(ty+150>H)ty=H-160;if(ty<10)ty=10;
      tt.style.left=tx+'px';tt.style.top=ty+'px';
    } else tt.style.display='none';
  }
});

canvas.addEventListener('mouseup',e=>{
  state.dragging=null;state.isPanning=false;
  if(ck&&cn){const dx=e.clientX-ck.x,dy=e.clientY-ck.y;if(Math.sqrt(dx*dx+dy*dy)<5&&Date.now()-ck.t<300){if(state.focusNode?.id===cn.id)clearFocus();else{state.selected=cn;setFocus(cn);updatePrompt();}}}
  else if(ck&&!cn){const dx=e.clientX-ck.x,dy=e.clientY-ck.y;if(Math.sqrt(dx*dx+dy*dy)<5){clearFocus();state.selected=null;renderNodeList();updatePrompt();}}
  ck=null;cn=null;
});

canvas.addEventListener('mouseleave',()=>{state.dragging=null;state.isPanning=false;state.hovered=null;document.getElementById('tooltip').style.display='none';draw();});

canvas.addEventListener('wheel',e=>{
  e.preventDefault();const r=canvas.getBoundingClientRect(),sx=e.clientX-r.left,sy=e.clientY-r.top;
  const oz=state.zoom,d=e.deltaY>0?0.92:1.08;
  state.zoom=Math.max(0.1,Math.min(3.5,state.zoom*d));
  const wx=(sx-state.pan.x-W/2)/oz,wy=(sy-state.pan.y-H/2)/oz;
  state.pan.x=sx-W/2-wx*state.zoom;state.pan.y=sy-H/2-wy*state.zoom;
  draw();drawMinimap();
},{passive:false});

canvas.addEventListener('dblclick',e=>{const r=canvas.getBoundingClientRect();const n=hitTest(e.clientX-r.left,e.clientY-r.top);if(n)cycleKnowledge(n);});

function cycleKnowledge(n){const o=['fuzzy','know','unknown'];n.knowledge=o[(o.indexOf(n.knowledge)+1)%3];draw();renderNodeList();updatePrompt();}

// ══════════════════════════════════════════════════════════════════════
// SIDEBAR
// ══════════════════════════════════════════════════════════════════════
function renderNodeList(){
  const list=document.getElementById('node-list');const q=state.searchQuery.toLowerCase();list.innerHTML='';
  LAYERS.forEach(layer=>{
    if(!state.layerFilters.has(layer.id))return;
    const ns=state.nodes.filter(n=>n.layer===layer.id&&(!q||n.label.toLowerCase().replace(/\n/g,' ').includes(q)||n.desc.toLowerCase().includes(q)));
    if(!ns.length)return;
    const g=document.createElement('div');g.className='layer-group';
    const col=state.collapsedLayers.has(layer.id);
    const h=document.createElement('div');h.className='layer-group-header';
    h.innerHTML=`<span class="arrow ${col?'collapsed':''}">▼</span><span class="layer-name" style="color:${layer.color}">${layer.label}</span><span class="layer-badge">${ns.length}</span>`;
    h.onclick=()=>{if(state.collapsedLayers.has(layer.id))state.collapsedLayers.delete(layer.id);else state.collapsedLayers.add(layer.id);renderNodeList();};
    g.appendChild(h);
    const body=document.createElement('div');body.className='layer-group-body'+(col?' collapsed':'');
    if(!col)body.style.maxHeight=(ns.length*38+10)+'px';
    ns.forEach(n=>{
      const inf=inFocus(n.id);
      const it=document.createElement('div');
      it.className='node-item'+(state.selected?.id===n.id?' selected':'')+(!inf&&state.focusNode?' dimmed':'');
      const pl=n.knowledge==='know'?'Know':n.knowledge==='fuzzy'?'Fuzzy':'???';
      it.innerHTML=`<span class="node-label">${n.label.replace(/\n/g,' ')}</span><span class="pill ${n.knowledge}" title="Click to cycle"><span class="pill-dot"></span>${pl}</span>`;
      it.querySelector('.pill').onclick=e=>{e.stopPropagation();cycleKnowledge(n);};
      it.onclick=()=>{state.selected=n;setFocus(n);const s=toS(n.x,n.y);state.pan.x+=W/2-s.x;state.pan.y+=H/2-s.y;draw();renderNodeList();updatePrompt();drawMinimap();};
      body.appendChild(it);
    });
    g.appendChild(body);list.appendChild(g);
  });
}

function filterNodes(){state.searchQuery=document.getElementById('search').value;renderNodeList();}

// ══════════════════════════════════════════════════════════════════════
// TOOLBAR
// ══════════════════════════════════════════════════════════════════════
document.getElementById('preset-group').addEventListener('click',e=>{
  const b=e.target.closest('.gbtn');if(!b)return;
  document.querySelectorAll('#preset-group .gbtn').forEach(x=>x.classList.remove('active'));
  b.classList.add('active');
  const map={all:['L1','L2','L3','L4','L5'],foundations:['L1'],'core-tech':['L1','L2'],implementation:['L2','L3'],scaling:['L3','L4'],agentic:['L3','L4','L5']};
  state.layerFilters=new Set(map[b.dataset.preset]||LAYERS.map(l=>l.id));
  state.nodes.forEach(n=>n.visible=state.layerFilters.has(n.layer));
  clearFocus();renderNodeList();centerView();draw();updatePrompt();drawMinimap();
});

document.getElementById('layout-group').addEventListener('click',e=>{
  const b=e.target.closest('.gbtn');if(!b)return;
  document.querySelectorAll('#layout-group .gbtn').forEach(x=>x.classList.remove('active-purple'));
  b.classList.add('active-purple');
  state.layoutMode=b.dataset.layout;runAutoLayout();
});

document.getElementById('size-group').addEventListener('click',e=>{
  const b=e.target.closest('.gbtn');if(!b)return;
  document.querySelectorAll('#size-group .gbtn').forEach(x=>x.classList.remove('active-pink'));
  b.classList.add('active-pink');
  state.sizeMode=b.dataset.size;SZ=SIZES[b.dataset.size];
  runAutoLayout();
});

// ══════════════════════════════════════════════════════════════════════
// ACTIONS
// ══════════════════════════════════════════════════════════════════════
function resetKnowledge(){state.nodes.forEach(n=>n.knowledge='fuzzy');draw();renderNodeList();updatePrompt();}
function markAllKnow(){state.nodes.forEach(n=>n.knowledge='know');draw();renderNodeList();updatePrompt();}
function centerView(){
  const vis=state.nodes.filter(n=>n.visible);if(!vis.length)return;
  let x1=Infinity,x2=-Infinity,y1=Infinity,y2=-Infinity;
  vis.forEach(n=>{x1=Math.min(x1,n.x);x2=Math.max(x2,n.x);y1=Math.min(y1,n.y);y2=Math.max(y2,n.y);});
  const cx=(x1+x2)/2,cy=(y1+y2)/2;
  state.zoom=Math.max(0.15,Math.min(1.5,Math.min(W/(x2-x1+300),H/(y2-y1+300))*0.85));
  state.pan.x=-cx*state.zoom;state.pan.y=-cy*state.zoom;
  draw();drawMinimap();
}

// ══════════════════════════════════════════════════════════════════════
// PROMPT
// ══════════════════════════════════════════════════════════════════════
function updatePrompt(){
  const kn=state.nodes.filter(n=>n.visible&&n.knowledge==='know').map(n=>n.label.replace(/\n/g,' '));
  const fz=state.nodes.filter(n=>n.visible&&n.knowledge==='fuzzy').map(n=>n.label.replace(/\n/g,' '));
  const un=state.nodes.filter(n=>n.visible&&n.knowledge==='unknown').map(n=>n.label.replace(/\n/g,' '));
  if(!fz.length&&!un.length){document.getElementById('prompt-text').textContent='All visible concepts marked as "Know". Click the pills in the sidebar or double-click nodes to mark as "Fuzzy" or "Unknown".';return;}
  const tids=new Set([...fz,...un].map(l=>state.nodes.find(n=>n.label.replace(/\n/g,' ')===l)?.id).filter(Boolean));
  const re=state.edges.filter(e=>NM[e.from]?.visible&&NM[e.to]?.visible&&(tids.has(e.from)||tids.has(e.to)));
  const ed=re.slice(0,15).map(e=>`${NM[e.from].label.replace(/\n/g,' ')} → ${NM[e.to].label.replace(/\n/g,' ')} (${e.label})`);
  const p=[`I'm learning about AI, Large Language Models, and Agentic AI from first principles to production.\n`];
  if(kn.length)p.push(`I already understand: ${kn.join(', ')}.\n`);
  if(fz.length)p.push(`I'm fuzzy on: ${fz.join(', ')}.\n`);
  if(un.length)p.push(`I don't understand: ${un.join(', ')}.\n`);
  if(ed.length)p.push(`Key relationships to explain:\n${ed.map(e=>`  • ${e}`).join('\n')}\n`);
  p.push(`\nPlease explain the fuzzy and unknown concepts, focusing on the relationships above. Build on what I already know. Use concrete examples, mathematical intuition, and practical code snippets. Progress from foundational concepts upward.`);
  document.getElementById('prompt-text').textContent=p.join('\n');
}

function copyPrompt(){navigator.clipboard.writeText(document.getElementById('prompt-text').textContent).then(()=>{const b=document.getElementById('copy-btn');b.textContent='Copied!';setTimeout(()=>b.textContent='Copy Prompt',1500);});}

// ══════════════════════════════════════════════════════════════════════
// INIT
// ══════════════════════════════════════════════════════════════════════
horizontalLayout();resize();
window.addEventListener('resize',resize);
renderNodeList();updatePrompt();
setTimeout(()=>{forceRelax();centerView();draw();drawMinimap();},50);
</script>
</body>
</html>
